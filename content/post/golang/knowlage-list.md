---
title: "golang常见问题"
date: 2020-08-21T18:00:58+08:00
draft: true
tags: ["golang常见问题"]
categories: ["golang"]
---

1. 解释goroutine，channel
2. php和go对比,go有哪些优势,静态语言有什么优势？
3. go调度模型，GMP模型 ,在协程的GMP模型中,如果一个io请求很大的话,这个时候P要怎么处理呢 -- 重点中的重点
4. 一个goroutine sleep了，操作系统是怎么唤醒的
4. go的调度过程,为什么要有P
4. goroutine泄漏有没有处理，设置timeout，select加定时器
5. go struct能不能比较,为什么?
6. go defer（for defer）defer的额外开销
7. select可以用于什么
8. context包实现机制,作用
9. client如何实现长连接
10. 主协程如何等其余协程完再操作
11. slice，len，cap，共享，扩容
12. map如何顺序读取,hash冲突，底层实现,怎么解决hash冲突
13. 实现set
14. 实现消息队列（多生产者，多消费者）
15. 大文件排序
16. 进程，线程，协程区别，特别是goroutine实现原理，为什么这么快，为什么线程切换开销相对于协程更大？
17. goroutine 和 kernel thread 之间是什么关系？
17. slice与数组区别，slice底层结构
18. Go的反射包怎么找到对应的方法
19. channel （有缓冲和无缓冲区别）,channel底层实现,是线程安全的吗
20. 退出程序时怎么防止channel没有消费完，这里一开始有点没清楚面试官问的，然后说了监听中断信号，做退出前的处理，然后面试官说不是这个意思，然后说发送前先告知长度，长度要是不知道呢？close channel下游会受到0值，可以利用这点（这里也有点跟面试官说不明白）
21. 生产者消费者模式，手写代码（Go直接使用channel实现很简单，还想着面试官会不会不让用channel实现，不用channel的可以使用数组加条件变量），channel缓冲长度怎么决定，怎么控制上游生产速度过快，这里没说出解决方案，只是简单说了channel长度可以与上下游的速度比例成线性关系，面试官说这是一种解决方案
22. 手写循环队列,写的循环队列是不是线程安全，不是，怎么保证线程安全，加锁，效率有点低啊，然后面试官就提醒Go推崇原子操作和channel
23. 看过啥源码，nsq（Go的消息中间件），简单问了我里面的waitgroup包证明我看过
24. sync.Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？不清楚，没看过这个的源码
25. tcp粘包，断包处理
26. goroutine调度用了什么系统调用，这个不会，面试官想从go问到操作系统，然后以为操作系统基础不好，就问了操作系统问题
27. go使用踩过什么坑（for range，数据库连接defer close）
28. go优缺点
29. go命令，go get，go tool，go test，go vet
30. go的值传递和引用
31. go的new和make区别
32. go怎么从源码编译到二进制文件，编译原理,使用gcc编译出可执行文件的中间步骤
33. go的锁如何实现，用了什么cpu指令
34. go的runtime如何实现
35. 看过sql的连接池实现吗
36. php的map和go的map的区别
37. go什么情况下会发生内存泄漏？（他说ctx没有cancel的时候，这个真不知道）
38. 怎么实现协程完美退出
39. 怎么理解go的interface,和php的接口有啥区别
40. go代码运行结果（闭包函数）
41. 切片和数组的区别
42. 向一个已经关闭了的channel写入数据会怎样，怎么判断一个channel已经关闭了。
43. defer是怎么执行的， defer和return哪个最后执行
44. golang gc原理
45. 讲一下协程
46. go map是并发安全的吗，不是，怎么实现并发安全,map还有什么实现
47. sync.map讲一下, sync.Map是如何实现的， sync.Map锁的粒度如何
48. go 编译大概是怎么个流程
49. golang gc机制
50. 三色标记法介绍
51. 甚至扯到了内存屏障
52. 标记清扫法相比其他gc算法的好处在哪
53. 有没有了解过go的其他框架
54. golang如何实现类
55. golang的接口
56. goalng协程，协程之间如何通信，底层机制是什么
57. golang中的CAS问题,如何实现无锁队列，CAS
58. 检测Golang内存泄漏的工具
59. Golang协程池,线程池
60. Golang如何优雅的结束协程。如何做到一个模块最多分配50个协程，一个模块最多只分配10个协程这种。
61. 为啥go高并发性能好。
62. 项目持续集成的时候如何处理测试问题。那每个开发人员使用gotest测试完自己的模块push上去了，但是最终merge到一起，要发布新版本了，需要再对系统整体需要测试的时候要怎么处理。
63. 主协程如何等其余协程完再操作
65. Golang的反射的实现原理
66. Golang的recover能打印哪些信息
67. 说说Golang如何创建一个map
68. 创建多个goroutine在多核的情况下是如何分配的
69. 长连接基于 TCP 怎么实现的
70. golang的逃逸分析
71. goroutine与操作系统的线程的比值，M：N？
72. 指针和引用区别
73. waitGroup底层实现
74. waitGroup 的使用,如何在waitGroup 的协程中实现一个协程失败，所有协程立刻终止
74. Go中如何判断发生了goroutine泄漏,当go服务部署到线上了，发现有内存泄露，该怎么处理
75. go里面panic知道吗，什么时候用，怎么用
76. 锁在项目里用过吗，知道悲观锁和乐观锁吗
77. 平时用的工具链和技术栈是什么 golang 踩过坑吗?
78. 闭包场景，调用栈原理，for循环那个函数那个坑
79. golang的变量分配
80. golang如何设计一个生产者消费者的模型
81. golang 的多态怎么做到
82. go线程安全怎么实现的
83. 一个a+b程序从编译到运行都发生了什么（从预编译到print显示到屏幕上）
87. 什么是可比较
88. unsafe.SizeOf()作用
89. golang db连接池源码分析