---
title: "绪论"
date: 2020-09-13T16:37:51+08:00
draft: true
tags: ["操作系统"]
categories: ["操作系统导论"]
---

### 1. 三大部分
虚拟化(virtualization)、并发(concurrency)、持久性(persistence)

### 2. 操作系统介绍
1. 程序执行过程
处理器从内存中获取(fetch)一条指令->对其进行解码(decode)(弄清楚这是哪条指令)->执行
2. 操作系统将物理资源转换为更通用、更强大且更容易使用的虚拟技术

### 2.1 虚拟化CPU
1. [例子](https://github.com/remzi-arpacidusseau/ostep-code/tree/master/intro/cpu.c)
2. 编译：gcc -o cpu cpu.c -Wall
3. 运行：./cpu A 
4. 多个同时运行: ./cpu A & ./cpu B &
5. 说明：尽管我们只有一个处理器、但是2个程序似乎在同时运行。
6. 将单个CPU转换为看似无限数量的CPU、从而让多个程序看似同时运行、这就是所谓的虚拟化CPU

### 2.2 虚拟化内存
1. [例子](https://github.com/remzi-arpacidusseau/ostep-code/tree/master/intro/mem.c)
2. 内存就是一个字节数组、要读取内存，就必须指定一个地址、才能访问存储在哪里的数据。要写入还要必须指定给定地址的数据
3. 程序运行时、一直要访问内存。程序的每个指令都在内存中、因此每次读取指令都会访问内存。
4. 运行： ./mem 1 ./mem 1
5. 每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程的地址空间。对于正在运行的程序，他完全拥有自己的物理内存。

### 2.3 并发
1. [例子](https://github.com/remzi-arpacidusseau/ostep-code/blob/master/intro/threads.c)
2. gcc -o thread thread.c -Wall -pthread

### 2.4 持久性
1. [例子](https://github.com/remzi-arpacidusseau/ostep-code/blob/master/intro/io.c)
2. 操作系统不会为每个应用程序创建专用的虚拟磁盘
